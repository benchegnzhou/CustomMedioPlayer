# 自定义的音乐播放器 #
* 下面是所有用到的知识点


## 列表主界面 ##

### 音乐标题 ###

### 视音频指示器 ###


## 视频界面 ##
	

### 视频模块（VideoView） ###
* 系统里唯一可以播放视频和音乐的类是MediaPlayer
* videoView只是一个界面， 他继承自 surfaceView 并对 MediaPlayer进行了封装
* MediaPlayer的生命周期

* MediaPlayer的状态转换图也表征了它的生命周期，搞清楚这个图可以帮助我们在使用MediaPlayer时考虑情况更周全，写出的代码也更具健壮性。


>  ![](http://i.imgur.com/Ta1NB9U.gif)

* 这张状态转换图清晰的描述了MediaPlayer的各个状态，也列举了主要的方法的调用时序，每种方法只能在一些特定的状态下使用，如果使用时MediaPlayer的状态不正确则会引发IllegalStateException异常。
 
* **Idle 状态：** 
  	* 当使用new()方法创建一个MediaPlayer对象或者调用了其reset()方法时，该MediaPlayer对象处于idle状态。这两种方法的一个重要差别就是：如果在这个状态下调用了getDuration()等方法（相当于调用时机不正确），通过reset()方法进入idle状态的话会触发OnErrorListener.onError()，并且MediaPlayer会进入Error状态；如果是新创建的MediaPlayer对象，则并不会触发onError(),也不会进入Error状态。
 
* **End 状态：**  
	* 通过release()方法可以进入End状态，只要MediaPlayer对象不再被使用，就应当尽快将其通过release()方法释放掉，以释放相关的软硬件组件资源，这其中有些资源是只有一份的（相当于临界资源）。如果MediaPlayer对象进入了End状态，则不会在进入任何其他状态了。
 
* **Initialized 状态：** 
	* 这个状态比较简单，MediaPlayer调用setDataSource()方法就进入Initialized状态，表示此时要播放的文件已经设置好了。
 
* **Prepared 状态：**  
	* 初始化完成之后还需要通过调用prepare()或prepareAsync()方法，这两个方法一个是同步的一个是异步的，只有进入Prepared状态，才表明MediaPlayer到目前为止都没有错误，可以进行文件播放。
 
* **Preparing 状态：** 
	*  这个状态比较好理解，主要是和prepareAsync()配合，如果异步准备完成，会触发OnPreparedListener.onPrepared()，进而进入Prepared状态。
 
* **Started 状态：**  
	* 显然，MediaPlayer一旦准备好，就可以调用start()方法，这样MediaPlayer就处于Started状态，这表明MediaPlayer正在播放文件过程中。可以使用isPlaying()测试MediaPlayer是否处于了Started状态。如果播放完毕，而又设置了循环播放，则MediaPlayer仍然会处于Started状态，类似的，如果在该状态下MediaPlayer调用了seekTo()或者start()方法均可以让MediaPlayer停留在Started状态。
 
* **Paused 状态：**  
	* Started状态下MediaPlayer调用pause()方法可以暂停MediaPlayer，从而进入Paused状态，MediaPlayer暂停后再次调用start()则可以继续MediaPlayer的播放，转到Started状态，暂停状态时可以调用seekTo()方法，这是不会改变状态的。
 
* **Stop 状态：**  
	* Started或者Paused状态下均可调用stop()停止MediaPlayer，而处于Stop状态的MediaPlayer要想重新播放，需要通过prepareAsync()和prepare()回到先前的Prepared状态重新开始才可以。
 
* **PlaybackCompleted状态：**  
	* 文件正常播放完毕，而又没有设置循环播放的话就进入该状态，并会触发OnCompletionListener的onCompletion()方法。此时可以调用start()方法重新从头播放文件，也可以stop()停止MediaPlayer，或者也可以seekTo()来重新定位播放位置。
 
* **Error状态：**  
	* 如果由于某种原因MediaPlayer出现了错误，会触发OnErrorListener.onError()事件，此时MediaPlayer即进入Error状态，及时捕捉并妥善处理这些错误是很重要的，可以帮助我们及时释放相关的软硬件资源，也可以改善用户体验。通过setOnErrorListener(android.media.MediaPlayer.OnErrorListener)可以设置该监听器。如果MediaPlayer进入了Error状态，可以通过调用reset()来恢复，使得MediaPlayer重新返回到Idle状态。

* <table><td bgcolor=#FFE4B5>
* <font color=##0000CD  size=6 face="黑体" > MediaPlayer的生命周期 </font>
* <font color=#0099ff  size=5 face="黑体" > 为了演示的方便，我们使用几副图片来展示这里面的逻辑关系 </font>

![](http://i.imgur.com/819OOXV.png)

* 1.MediaPlayer进入prepare()状态后，播放相关的资源就在内存里准备好了，这时视频可以start和stop
 
![](http://i.imgur.com/pM2FaA2.png)

* 2.当计入stop() 状态，资源已经被释放，此时必须重新 prepare() 才能恢复播放

![](http://i.imgur.com/JODZtCt.png)

* 3. prepare() 方法是在当前线程执行的，prepareAsync()方法是在子线程中执行的（资源的加载是特别的耗时的，应该放在子线程中进行调用，每次调用麻烦，这时系统为我们准备了prepareAsync()这个方法，系统的底层会默认的为我们开启一个子线程）

![](http://i.imgur.com/tiAPlKk.png)

* 4.MediaPlayer的Stop 、 reset 、 release方法的不同
	* Stop() 之后MediaPlayer的路径还在，目前处于stoped() 状态，可以再次直接调用start直接播放
	* reset() 之后MediaPlayer的路径信息不再存在，MediaPlayer目前处于Idle状态，这时可以重新设置新的路径，开始播放，相当于重新初始化了或者创建了一个MediaPlayer
	* release() 之后当前的MediaPlayer资源被释放，就不可以使用了

* 这几张图是对谷歌提供的mediaPlayer生命周期的简化
*  
* 
* 
</td></table>





### 系统电量 ###

### 自定义的进度条 ###

### 屏幕上下滑动修改音量和亮度 ###

### 全屏（单击、双击、长按） ###

### 相应文件管理器调用 ###

### 集成第三方的视频解码库（Vitamio） ###



## 音乐界面 ##


### 自定义界面通知 ###

### 示波器动画（帧动画） ###

### 自定义歌词控件 ###

### 后台服务处理界面 ###

### 自定义通知界面 ###




 


# 项目开始 #


* 在最初开始项目之前一定要注意，有机会把包创建了就行动，然自己主宰开发的规则
* 这样在多人开发的时候可以建立一套统一的规范，方便后期代码的维护

 
### 项目的框架 ###

* 一个代码开始的时候，不是首先从SplashActivity开始的，而是首先通过从定义BaseActivity 开始着手的，这就是框架

* 在面试的时候我们会经常的被问到，你们的项目中都用到那些的框架
* 其实我们的项目里边的框架除了反射，注解，配置文件（builderConfiger）还有BaseActivity，BaseFragment这些；
* 其实只要是我们对代码进行约定的都是一个项目的框架。
-'-'
### 操作解耦 ###
* 在使用的过程中,广播注册和设置adapter，以及setListener都是为了解耦





## 在项目中生成全局文件的方法 ##

* 在文件buildConfig中添加如下代码： 

		buildTypes {   
	        debug {
	            //调试模式下打开log日志控制台输出
	            buildConfigField "boolean", "LOG_DEBUG", "true"
	            debuggable true
	            minifyEnabled false
				//生成对应的文件
	            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-project.txt'
	            signingConfig signingConfigs.debug
	        }
	        release {
	            //正式上线时，关闭log打印
	            buildConfigField "boolean", "LOG_DEBUG", "false"
	            minifyEnabled false
	            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
	        }
	    }


* 相应的配置会出现在编译器给我们生成buildConfig.java文件中

* 这个是我们自定义全局文件变量的规则：   buildConfigField "boolean", "LOG_DEBUG", "true"，这样定义好后我们就可以很轻松的更改一处代码就可以将全局的代码全部替换了，方便代码维护


* 值得注意的是buildConfig.java文件是系统默认生成的



# 代码步骤 #

## 1. 基础框架搭建 ##

### 1.1 添加项目所需要的依赖 ###
### 1.2 增加utils工具包，从以前的工程中直接的拷贝 ###
### 1.3 创建自己的BaseActivity,增加自己的规则，比如InitView,initListener,initAdapter,initData等等  ###
### 1.4 将子类公共的部分直接的放到BaseActivity中进行处理，比如放回button的操作等，节约代码量 ###
* 这里涉及到一个手动创建资源id的方法
 
> * 创建

![](http://i.imgur.com/2vvawqp.png)

![](http://i.imgur.com/BX4kpZG.png)

> * 引用

![](http://i.imgur.com/gdXpz8Z.png)





## Splash界面延时跳转 ##
* 实现的方案有以下的几种
* 1.计时器Timer
* 2.子线程延时
* 3.使用handler.postDelay()方法

* 这里注意的是handler是android系统自带的使用时更加方便管理，尽量多的使用



## BaseActivity有两个作用 ##
* 约定代码结构，统一编程风格
* 提供子类通用的代码，节约代码量




## 快捷键实现构造方法 ##

Alt+insert  快速的实现构造方法



## 在使用activity的时候会出现一定的兼容性的问题 ##

baseActivity 是继承 V4 包的 FragmentActivity 和还是 V7 包的 AppCompatActivity

#### FragmentActivity和Activity的区别  ####

>  * Fragment是Android 3.0以后的东西，为了在低版本中使用Fragment就要用到android-support-v4.jar兼容包,而FragmentActivity就是这个兼容包里面的，它提供了操作Fragment的一些方法，其功能跟3.0及以后的版本的Activity的功能一样。
下面是API中的原话：
FragmentActivity is a special activity provided in the Support Library to handle fragments on system versions older than API level 11. If the lowest system version you support is API level 11 or higher, then you can use a regular Activity.

**主要区别如下：**

- 1、FragmentActivity 继承自Activity，用来解决Android 3.0之前无法使用Fragment的问题，所以在使用的时候需要导入android-support-v4.jar兼容包，同时继承 FragmentActivity，这样在Activity中就能嵌入Fragment来实现你想要的布局效果。 
- 2、当然Android 3.0之后你就可以直接继承自Activity，并且在其中嵌入使用Fragment。 
- 3、获得FragmentManager的方式也不同 
- Android 3.0以下：getSupportFragmentManager() 
- Android 3.0以上：getFragmentManager() 



## 标题选中，这里有了一种更好的解决的方案 （厉害了我的哥）##

* 当有多个标签选中和不选中状态改变的时候，我们以前的做法是直接的代码设置文本的颜色和文本的字体大小
* 这里的新的解决的方案就是通过选择器的的形式进行处理


* **方法抽取**
* 现将想要抽取的代码中的所有的写死的变量，替换成变量
* 然后直接抽取

* 1.替换之前代码： 

 			tvVideo.setSelected(position == 0);
            if (position == 0) {
                ViewCompat.animate(tvVideo).scaleX(1.1f).scaleY(1.1f).setDuration(300).setInterpolator(new AnticipateOvershootInterpolator()).start();
            }else {
                ViewCompat.animate(tvVideo).scaleX(0.9f).scaleY(0.9f).setDuration(300).setInterpolator(new AnticipateOvershootInterpolator()).start();

            }


* 2.替换其中的变量tvMusic 和 0

		 TextView tab= tvVideo;
         int tabPosition=0;

* 3.替换完成后，Alt+ shift+ M 方法抽取，获得方法upDataTab（）{}


		private void upDataTab(int position, TextView tab, int tabPosition) {
	        //变色
	        tab.setSelected(position == tabPosition);
	
	        //缩放
	        //写代码的时候注意，尽量的提取
	        // 动画设置，没有必要进行版本的判断，谷歌提供的兼容类
	        if (position == 0) {
	            ViewCompat.animate(tvVideo).scaleX(1.1f).scaleY(1.1f).setDuration(300).setInterpolator(new AnticipateOvershootInterpolator()).start();
	        }else {
	            ViewCompat.animate(tvVideo).scaleX(0.9f).scaleY(0.9f).setDuration(300).setInterpolator(new AnticipateOvershootInterpolator()).start();
	
	        }
        }





## 动画部分这个需要看，仔细的总结 ##
- 动画的分类
- 动画的差值器
- 动画的版本兼容
- 不同版本的动画
- 值动画的使用



## 指示器操作 ##

### requestLayout 和 invalidate的区别 ###
* 1. requestLayout要求重新计算大小并刷新界面
* 2. invalidate只要求刷新界面

### 计算知识器的位置 ###
* 指示器的位置算法
	* 最终要使用的位置 = 其实位置 + 偏移位置
	* 其实位置 = position * 指示器的宽
	* 偏移位置 = 页面展开百分比 * 指示器的宽


## 手机多媒体信息的获取 ##
* 手机中的多媒体信息都是存放在mediaStore中的，所有的播放器等的列表都是同过一个多媒体的 MediaProvider 来获取信息的
* 其实在系统的 MediaProvider 文件中会找到Android系统扫描到的多媒体文件，路径地址

找到文件管理器：
	
	data --> data --> com.android.provider.media --> databases
> 
	--> external.db 这个是内存和sd卡公共的 
    --> internal.db 这个是android 系统使用的 

* 其中系统存储的部分是我们没有权限操作的这里我们不关心，直接的跳过



## Android Studio的一个使用技巧 --- 快速查找方法 ##

	ctrl + F12可以快速的定位当前类的方法



### android studio 看不到系统类源码解决 ###

* android studio的源码是自动下载关联的，如果看不到，就是没有下载，或者是官方没有提供，只需要在buildGradle里面修改targeVersion就可以，或者也可以在sdk中系在对应的版本


## 熟悉CursorAdapter的使用 ##
* CursorAdapter是谷歌提供的一个在listviewAdapter基础上的封装，他会将查询出来的数据放在list中进行展示，我们只需要实现其中的几个方法就可以的


* **1.需要实现下面这几个方法** 

   * 1.两个构造
 
			public cursorListAdapter(Context context, Cursor c) {
		        super(context, c);
		    }
		
		    public cursorListAdapter(Context context, Cursor c, boolean autoRequery) {
		        super(context, c, autoRequery);
		    }


	* 2.方法 newView() 创建view 和  方法 bindView() 绑定数据


			/**
		     * 创建新的view 和 viewHolder
		     *
		     * @param context
		     * @param cursor
		     * @param parent
		     * @return
		     */
		    @Override
		    public View newView(Context context, Cursor cursor, ViewGroup parent) {
		        View view = LayoutInflater.from(context).inflate(R.layout.video_list_item, null);
		        ViewHolder holder = new ViewHolder();
		        holder.tv_tittle = (TextView) view.findViewById(R.id.tv_video_list_tittle);
		        holder.tv_size = (TextView) view.findViewById(R.id.tv_video_list_videosize);
		        holder.tv_duration = (TextView) view.findViewById(R.id.tv_video_list_videoDuration);
		
		
		        view.setTag(holder);   //想要复用成功，必须设置tag
		        return view;
		    }
		
		    /**
		     * 填充条目内容    此时 view不可能为空  因为不为空则复用，为空就调用newView创建
		     *
		     * @param view
		     * @param context
		     * @param cursor  已经移动到指定位置的cursor 我们只需要解析对应的内容就可以了
		     */
		    @Override
		    public void bindView(View view, Context context, Cursor cursor) {
		        ViewHolder holder = (ViewHolder) view.getTag();    //这个不可能为空
		        holder.tv_tittle.setText(cursor.getString(cursor.getColumnIndex(Media.TITLE)));
		        holder.tv_size.setText(cursor.getString(cursor.getColumnIndex(Media.SIZE)));
		        holder.tv_duration.setText(cursor.getString(cursor.getColumnIndex(Media.DURATION)));
		
		    }
		

			//缓存服用holder类
		    private class ViewHolder {
		        TextView tv_tittle, tv_duration, tv_size;
		    }


* **2. adater调用**


		//获取手机里的数据
        //1. 获取内容观察者
        ContentResolver contentResolver = getActivity().getContentResolver();
        //2. 进行查询    Cursor query(Uri, String[], String, String[], String)
        //查询的位置， 查询的关键字， 查询条件占位符 ， 查询条件填充占位符的数组 ，排序
        Cursor cursor = contentResolver.query(Media.EXTERNAL_CONTENT_URI, new String[]{Media.DATA, Media.SIZE, Media.DURATION, Media.TITLE}, null, null, null);
        CursorUtils.printCursor(VideoListFragment.class,cursor);
        cursorListAdapter.swapCursor(cursor);    //相当于  notifyDataSetInvalidated();  替换原有的cursor   其实底层调用的还是   notifyDataSetInvalidated();这个方法



* **3. 报错解决**
* 这时候会出现报错

		java.lang.IllegalArgumentException: column '_id' does not exist


* 原因
* 查看 CursorAdapter 的源码，会发现有这样的解释

			
		/**
		 * Adapter that exposes data from a {@link android.database.Cursor Cursor} to a
		 * {@link android.widget.ListView ListView} widget.
		 * <p>
		 * The Cursor must include a column named "_id" or this class will not work.
		 * Additionally, using {@link android.database.MergeCursor} with this class will
		 * not work if the merged Cursors have overlapping values in their "_id"
		 * columns.
		 */

* 大体是说在数据库查询的时候，必须包含The Cursor must include a column named "_id" or this class will not work.  "_id"的指定列,也就是我们常常会说的主列  

* 知道了这些剩下的就简单了

	* 1.在这个的基础上添加一个主列  "_id"
	 
			/2. 进行查询    Cursor query(Uri, String[], String, String[], String)
		        //查询的位置， 查询的关键字， 查询条件占位符 ， 查询条件填充占位符的数组 ，排序
		        Cursor cursor = contentResolver.query(Media.EXTERNAL_CONTENT_URI, new String[]{Media.DATA, Media.SIZE, Media.DURATION, Media.TITLE}, null, null, null);


	* 2.成为这样的 


			//2. 进行查询    Cursor query(Uri, String[], String, String[], String)
	        //查询的位置， 查询的关键字， 查询条件占位符 ， 查询条件填充占位符的数组 ，排序
	        Cursor cursor = contentResolver.query(Media.EXTERNAL_CONTENT_URI, new String[]{Media._ID,Media.DATA, Media.SIZE, Media.DURATION, Media.TITLE}, null, null, null);

		
* 其实巧了，在我们的这一张表里面正好有 "_id"	这个列
* 如果没有的解决就是使用别名 比如 "tvName as _id"  ,随便指定一个主列名
  
	* 3.没有这个列的情况是这样的
	 
			//2. 进行查询    Cursor query(Uri, String[], String, String[], String)
	        //查询的位置， 查询的关键字， 查询条件占位符 ， 查询条件填充占位符的数组 ，排序
	        Cursor cursor = contentResolver.query(Media.EXTERNAL_CONTENT_URI, new String[]{"tvName as _id" ,Media.DATA, Media.SIZE, Media.DURATION, Media.TITLE}, null, null, null);

* 好的运行一下，问题完美解决	 

展示一下现在的样子吧

![](http://i.imgur.com/mZvR631.png) 


## 数据查询代码优化，查询数据库是一个耗时操作，应该开启子线程完成，但是更爽的是系统为我们提供了一个类AsyncQueryHandler，完成这个操作 ##

* 优化前这部分代码在主线程中调用


  		//获取手机里的数据
        //1. 获取内容观察者
        ContentResolver contentResolver = getActivity().getContentResolver();
        //2. 进行查询    Cursor query(Uri, String[], String, String[], String)
        //查询的位置， 查询的关键字， 查询条件占位符 ， 查询条件填充占位符的数组 ，排序
        Cursor cursor = contentResolver.query(Media.EXTERNAL_CONTENT_URI, new String[]{Media._ID,Media.DATA, Media.SIZE, Media.DURATION, Media.TITLE}, null, null, null);
        CursorUtils.printCursor(VideoListFragment.class,cursor);
        cursorListAdapter.swapCursor(cursor);    //相当于  notifyDataSetInvalidated();  替换原有的cursor   其实底层调用的还是   notifyDataSetInvalidated();这个方法
     


* 我们自己开启一个子线程，有点没必要，可以使用已经封装好的

	 ContentResolver contentResolver = getActivity().getContentResolver();
 
        /**
         * 本来需要自己创建一个子线程完成这个操作，但是扩展性更好的是使用系统封装好的 AsyncQueryHandler 来完成这个操作
         * 这个方法在完成查询的时候在主线程中调用
         */
        AsyncQueryHandler asyncQueryHandler = new MyAsyncQueryHandler(contentResolver);

        
        asyncQueryHandler.startQuery( VIDEO_QUERY,cursorListAdapter ,Media.EXTERNAL_CONTENT_URI, new String[]{Media._ID, Media.DATA, Media.SIZE, Media.DURATION, Media.TITLE}, null, null, null);


* 参数解释：

		int token,   相当于handler的what  用于区分事件的类型
        Object cookie,  相当于handler的Object ，用于传递 需要刷新的控件的
        android.net.Uri uri,      下面的就是query的那一套了，直接拷贝
        String[] projection,
        String   selection,
        String[] selectionArgs,
        String   orderBy


* MyAsyncQueryHandler中的相关代码



		/**
		 *  * 作者：Zbc on 2016/12/7 00:11
		 *  * 邮箱：mappstore@163.com
		 * 功能描述：
		 *   这个类可以实现数据库的异步增 ， 删 ， 改 ， 查 ，使用的时候只需要重写相应的方法就好了，执行的过程都是在主线程中
		 *   使用的最后不要忘记调用startQuery()方法开启线程操作
		 *   使用的方法类比handler
		 */
		public class MyAsyncQueryHandler extends AsyncQueryHandler {
		
		
		    public MyAsyncQueryHandler(ContentResolver resolver) {
		        super(resolver);
		    }
		
		    /**
		     * 查询完成后这个方法会在主线程回调
		     * @param token    相当于handler中的what
		     * @param cookie   相当于handler中的Object，传递刷新的控件
		     * @param cursor    当前一条记录的cursor
		     */
		    @Override
		        protected void onQueryComplete(int token, Object cookie, Cursor cursor) {
		            super.onQueryComplete(token, cookie, cursor);
		        cursorListAdapter mAdapter = (cursorListAdapter) cookie;  //控件还原
		        CursorUtils.printCursor(MyAsyncQueryHandler.class,cursor);
		        mAdapter.swapCursor(cursor);    //相当于  notifyDataSetInvalidated();  替换原有的cursor   其实底层调用的还是   notifyDataSetInvalidated();这个方法
		        }
		}


*  AsyncQueryHandler底层会开启一个子线程完成数据库的增删改查的操作，并同过handler的形式进行数据的传递和界面的刷新


## 将一个类快速的转换匿名内部类 ##

![](http://i.imgur.com/R9jLvPo.png)


![](http://i.imgur.com/jpMSjUr.png)

* 好了，到这里就打工告成了


## android Studio 快速生成get set 构造等方法的快捷键 ##


   Alt + insert


## 序列化接口用到了，而且使用的时候很方便，多看一下 ##

		public  class VideoListItem implements Serializable





## 使用videoView播放视频 ##




* 防止MediaPlayer异步资源加载报错，应该将播放视频放在监听里面进行

正确的做法是：

 		String videoPath = videoListItem.getPath();
	    vdVideoview.setVideoPath(videoPath);    //设置播放路径
	       
		/**
         * 设置MediaPlayer的异步加载监听
         * 这个方法在资源异步加载完成后调用
         * 在给videoView设置完路径后直接的调用vdVideoview.start(); 可能会在资源异步加载还没完成的时候就调用播放start了
         */
         vdVideoview.setOnPreparedListener(new MediaPlayer.OnPreparedListener() {
            @Override
            public void onPrepared(MediaPlayer mp) {
                vdVideoview.start();          //开启播放
            }
        });
		 



 
* 如果快速开发只是实现共能还可以使用系统自带的控制器


		//公司要求快速开发的时候，可以使用系统自带的播放控制进度条，虽然丑但是还不错
        //vdVideoview.setMediaController(new MediaController(this));



## VideoPlayer界面布局 ##

* 布局复杂的时候尽量的使用include

	
	    <!--顶部栏-->
	    <include layout="@layout/activity_video_player_top"/>
	
	    <!--底部栏-->
	    <include layout="@layout/activity_video_player_bottom"/>

 

## 自定义进度条seekBar ##

* 总体感觉这个还是蛮有新意的

* 首先随便找到系统的一个精度条样式 
 
		style="@android:style/Widget.SeekBar"
 查看他的源码


	    <style name="Widget.SeekBar">
	        <item name="indeterminateOnly">false</item>    
	        <item name="progressDrawable">@drawable/progress_horizontal</item>
	        <item name="indeterminateDrawable">@drawable/progress_horizontal</item>
	        <item name="minHeight">20dip</item>
	        <item name="maxHeight">20dip</item>
	        <item name="thumb">@drawable/seek_thumb</item>
	        <item name="thumbOffset">8dip</item>
	        <item name="focusable">true</item>
	        <item name="mirrorForRtl">true</item>
	    </style>


* indeterminateOnly: 表示进度值是否确定，true表示不确定，false表示确定   通俗的说就是进度条是不是可以拉
* progressDrawable: 进度条的背景，第一进度，第二进度样式
* indeterminateDrawable： 定义不确定模式是否可拉
* maxHeight： 背景色最大高度限制
* minHeight： 背景色最小高度限制
* thumb    :  按下是的图形，就是拖动的小点
* thumbOffset： 小点的偏移量
* focusable   ： 是否可以获取焦点
* mirrorForRtl： 定义了相关画板如果需要反映在RTL模式  



* 现在我们就参考系统的样式，设置我们的进度条

		<!--自定义seekBar的样式，最简单的方式就是查看系统的源码，然后修改对应的属性-->
	    <!--通过源码可以发现
	    android:thumb="@mipmap/video_progress_thumb"  //拇指按下的图形
	    android:thumbOffset="0dp"   图形的偏移量
	    参考系统样式
	    android:maxHeight="6dp" 可以限定进度条背景的高度
	     style="@android:style/Widget.SeekBar"-->
	    <SeekBar
	        style="@android:style/Widget.SeekBar"
	        android:layout_width="0dp"
	        android:layout_weight="1"
	        android:maxHeight="6dp"
        	android:minHeight="6dp"
	        android:thumb="@mipmap/video_progress_thumb"
	        android:thumbOffset="0dp"
	        android:progress="40"
	        android:progressDrawable="@drawable/video_progress_seekbar"
	        android:layout_height="wrap_content" />


* 进度条背景，进度样式 video_progress_seekbar.xml文件的代码

直接的拷贝系统的源代码修改就好了：

		<?xml version="1.0" encoding="utf-8"?>

	 
		
		<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
		
		    <item android:id="@android:id/background" android:drawable="@drawable/video_seekbar_bg">
		        <!--<shape>
		            <corners android:radius="5dip" />
		            <gradient
		                android:startColor="#ff9d9e9d"
		                android:centerColor="#ff5a5d5a"
		                android:centerY="0.75"
		                android:endColor="#ff747674"
		                android:angle="270"
		                />
		        </shape>-->
		    </item>
		
		    <item android:id="@android:id/secondaryProgress"   >
		        <!--<clip>
		            <shape>
		                <corners android:radius="5dip" />
		                <gradient
		                    android:startColor="#80ffd300"
		                    android:centerColor="#80ffb600"
		                    android:centerY="0.75"
		                    android:endColor="#a0ffcb00"
		                    android:angle="270"
		                    />
		            </shape>
		        </clip>-->
		        <shape >
		            <corners android:radius="5dp"/>
		            <solid android:color="#2595FD" >
		
		            </solid>
		        </shape>
		
		    </item>
		
		    <item android:id="@android:id/progress"  >
		       <!-- <clip>
		            <shape>
		                <corners android:radius="5dip" />
		                <gradient
		                    android:startColor="#ffffd300"
		                    android:centerColor="#ffffb600"
		                    android:centerY="0.75"
		                    android:endColor="#ffffcb00"
		                    android:angle="270"
		                    />
		            </shape>
		        </clip>-->
		        <shape >
		            <corners android:radius="5dp"/>
		            <solid android:color="#2595FD" >
		
		            </solid>
		        </shape>
		    </item>
		
		</layer-list>



* 值得注意的是：item中是直接可以设置 drawable图形的,以后这种技能要学会了-
 

		<item android:id="@android:id/secondaryProgress"  android:drawable="@drawable/video_seekbar_progress" />


* 但是在使用的时候发现只能够实用drawable的出图片和.9图片的情况不然会出现季度失效的情况，暂时不知道为什么
* 出现背景很粗的问题尝试添加


		android:maxHeight="6dp"
       	android:minHeight="6dp"

两个属性

*  如果出现seekBar在不同品牌手机适配问题的时候，可以尝试美工且多套图来完成适配






## 界面的暂停和播放 ##
* 注意的是在工作的时候ui界面的更新和功能逻辑的更新一定是分开的，使用不同的方法，方便维护


* 按钮点击的时候更新界面和播放的状态

		case R.id.iv_video_pause:  //播放暂停按钮
                upDataPause();
                upDataPauseBtn();
                break;


* 播放控制的逻辑代码 upDataPause()

	
	    /**
	     * 暂停更新的方法
	     * 作用： 切换暂停的状态和更新暂停按钮的图片
	     */
	    private void upDataPause() {
	        if (vdVideoview.isPlaying()) {
	            vdVideoview.pause();   //调用videoView的暂停方法
	        } else {
	            vdVideoview.start();   //调用videoView的播放方法
	        }

* 播放控制的界面刷新代码 upDataPauseBtn();

		 /**
	     * 暂停播放界面的更新
	     * 工作的时候界面的逻辑代码和功能代码是分开的，这样方便后期的维护
	     * 同时供代码和界面代码单独写还可以提高两者调用的灵活性
	     */
	    private void upDataPauseBtn() {
	        if (vdVideoview.isPlaying()) {
	            ivVideoPause.setImageResource(R.drawable.btn_video_pause);
	        } else {
	            ivVideoPause.setImageResource(R.drawable.btn_video_play);
	        }
	
	    }



* 在开始播放的时候初始化，按钮的状态


		/**
         * 设置MediaPlayer的异步加载监听
         * 这个方法在资源异步加载完成后调用
         * 在给videoView设置完路径后直接的调用vdVideoview.start(); 可能会在资源异步加载还没完成的时候就调用播放start了
         */
        vdVideoview.setOnPreparedListener(new MediaPlayer.OnPreparedListener() {
            @Override
            public void onPrepared(MediaPlayer mp) {
                //资源加载完成，开启播放
                vdVideoview.start();
                //开始播放的时候更新按钮的播放状态
                upDataPauseBtn();
            }
        });


* **这里也体现出一个设计的思想：解耦，将业务的逻辑和UI分离开，这样代码用起来十分的爽**



## 系统电量监听 ##

* 实现匿名对象快速转换成成员对象的快捷键  ctrl + alt + V


* 系统电量的变换是通过广播的形式发送的

* 1.注册广播


		// 注册广播获取系统电量信息
        IntentFilter filter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);
        broadcastReceiver = new VideoBroadcastReceiver();
        registerReceiver(broadcastReceiver, filter);
	

* 2.广播注销（有注册就会有注销）

		@Override
	    protected void onDestroy() {
	        super.onDestroy();
	        // 广播有注册就得有反注册
	        unregisterReceiver(broadcastReceiver);
	    }

* 3.监听回调

		 /**
	     * 接收电池变化信息的广播
	     */
	    private class VideoBroadcastReceiver extends BroadcastReceiver {
	        @Override
	        public void onReceive(Context context, Intent intent) {
	             //获取系统电量
	            int level = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, 0);
	            updataBatteryPic(level);
	        }
	    }


* 4.UI界面更新

		 /**
	     * 时时更新电量显示图片
	     * @param level
	     */
	    private void updataBatteryPic(int level) {
	        LogUtil.e("当前系统电量"+level);
	        if(level<10){
	            ivVideoElectric.setImageResource(R.mipmap.ic_battery_0);
	        }else if(level<20){
	            ivVideoElectric.setImageResource(R.mipmap.ic_battery_10);
	        }else if(level<40){
	            ivVideoElectric.setImageResource(R.mipmap.ic_battery_20);
	        }else if(level<60){
	            ivVideoElectric.setImageResource(R.mipmap.ic_battery_40);
	        }else  if(level<80){
	            ivVideoElectric.setImageResource(R.mipmap.ic_battery_60);
	        }else if(level<100){
	            ivVideoElectric.setImageResource(R.mipmap.ic_battery_80);
	        }else {
	            ivVideoElectric.setImageResource(R.mipmap.ic_battery_100);
	        }
		}



## 音乐音量调节 ##

* 系统的媒体音量和系统音量是由AudioManger来控制的

> AudioManger获取 AudioManager myAudioManager = (AudioManager) getSystemService(AUDIO_SERVICE);


* 界面音量初始化

		//初始化音量进度
        myAudioManager = (AudioManager) getSystemService(AUDIO_SERVICE);
        //获取系统的最大音量
        int maxVolume = myAudioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC);//AudioManager这里面封装了来电铃声，通话，蓝牙，系统，闹钟，音乐等各种情景的铃声
        //当前音量获取
        int currentVolume = myAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC);
        //根据系统的音量界面初始化当前的音量值
        sbVideoCurrentVolume.setMax(maxVolume);
        sbVideoCurrentVolume.setProgress(currentVolume);


* 获取当前进度条的变化，并设置给系统

		
	    /**
	     *
	     * 当进度条改变的时候调用
	     */
	    private class MyOnSeekBarChangeListener implements SeekBar.OnSeekBarChangeListener {
	        @Override
	        public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
	            if(!fromUser){return;}  //只处理来自用户的操作
	            /**
	             * 根据进度条修改系统的音量
	             *  参数1： 参数的类型（媒体音量还是通话等）
	             *  参数2：目标值
	             *  参数3： 是不是显示系统自带的Dialog 0：不显示，1：显示
	             */
	            myAudioManager.setStreamVolume(AudioManager.STREAM_MUSIC,progress,0);
	        }
		}



* 将音量设置给系统的代码要注意

		 myAudioManager.setStreamVolume(AudioManager.STREAM_MUSIC,progress,0);

*  public void setStreamVolume(int streamType, int index, int flags) {}
* setStreamVolume()作用根据进度条修改系统的音量
* 参数解释



 streamType  | 参数的类型（媒体音量还是通话等）
:------------:|---------|
index		 |目标音量值，不同的手机的音量等级不一样，应该通过设置seekbar表示的最大值限定
flags   	 | 是不是显示系统自带的Dialog 0：不显示，1：显示
	    


* 像这样繁琐的方法完全可以进行二次封装
 
		 /**
	     * 当前媒体音量是设置
	     * @param flag_showSystemDialog  是不是显示系统自带的音量进度条
	     * @param volume  目标设置音量值
	     */
	    private void setCurrentVolute( int volume ,int flag_showSystemDialog) {
	        myAudioManager.setStreamVolume(AudioManager.STREAM_MUSIC, volume,flag_showSystemDialog);
	        //同步更新进度条
	        sbVideoCurrentVolume.setProgress(volume);
	    }
	
	    /**
	     * 获取当前的媒体音量
	     * @return
	     */
	    private int getCurrentVolume() {
	        return myAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC);
	    }  


## 手指上下滑动修改音量和亮度 ##

* **音量修改**

* 获取和修改音量需使用AudioManger，操作声音的时候需要说明具体的声音类型（电话、音乐、闹铃等）
* 手指滑动时，修改系统音量的算法
	* 最终使用的音量 = 起始音量 + 偏移音量
	* 偏移音量 = 最大音量 * 划过屏幕的百分比
	* 划过屏幕的百分比 = 手指划过屏幕的距离 / 屏幕的高度
	* 手指划过屏幕的距离 = 手指当前的位置 - 是指落下的位置

* 在滑动监听中对手势的移动进行判断

		/**
	     * 屏幕触摸事件的监听
	     * 最终使用的音量 = 起始音量 + 偏移音量
	     * 偏移音量 = 最大音量 * 划过屏幕的百分比
	     * 划过屏幕的百分比 = 手指划过屏幕的距离 / 屏幕的高度
	     * 手指划过屏幕的距离 = 手指当前的位置 - 是指落下的位置
	     *
	     * @param event
	     * @return true 事件拦截自己处理
	     */
	    @Override
	    public boolean onTouchEvent(MotionEvent event) {
	        switch (event.getAction()) {
	            case MotionEvent.ACTION_DOWN:
	                mStartY = event.getY();
	                mStartX = event.getX();
	                //系统当前音量获取
	                moveDownVolume = getCurrentVolume();
	                //获取起始透明度
	                startAlpha = ViewCompat.getAlpha(viewVideoAlphaCover);
	                break;
	            case MotionEvent.ACTION_MOVE:
	                float mCurrentY = event.getY();
	                //滑动的距离
	                float offsetY = mStartY - mCurrentY;
	
	                //手势滑动的百分比
	                float movePresent = offsetY / mHalfScreenH;
	                if (mStartX < mHalfScreenW) {   //左侧屏幕滑动
	                    //根据手指移动百分比，改变屏幕亮度
	                    upDataMoveAlpha(movePresent);
	                } else {
	                    //根据手指移动百分比，改变媒体音量
	                    upDataMoveVolume(movePresent);
	                }
	                break;
	
	        }
	
	        return true;
	    }

* 获取屏幕的宽高发现每次调用浪费资源，提取了全局变量

		 //获取屏幕的高度的一半
	    private int mHalfScreenH;
	    //获取屏幕的宽度的一半
	    private int mHalfScreenW;

* 初始化放在了initData()方法中

	 	//获取屏幕的高度
        mHalfScreenH = getWindowManager().getDefaultDisplay().getHeight() / 2;
        //获取屏幕的宽度
        mHalfScreenW = getWindowManager().getDefaultDisplay().getWidth() / 2;

* 根据手指滑动改变媒体音量，upDataMoveVolume() 方法

		/**
	     * 根据手指滑动改变媒体音量
	     *
	     * @param movePresent
	     */
	    private void upDataMoveVolume(float movePresent) {
	        //获取系统的最大音量
	        int maxVolume = sbVideoCurrentVolume.getMax();
	        //音量的偏移值
	        int offsetVolume = (int) (maxVolume * movePresent);
	        //最终的音量
	        int finalVolume = moveDownVolume + offsetVolume;
	        //将音量设置给系统
	        setCurrentVolume(finalVolume, 0);
	    }
	
* upDataMoveAlpha() 根据手指滑动改变屏幕亮度，发现系统没有为我们处理下限和上限我们自己增加了判断if (finalApha >= 0 && finalApha <= 0.8)   0.8是为了防止黑屏

	    /**
	     * 根据手指滑动改变屏幕亮度
	     * 这里折中，使用蒙版的形式改变亮度
	     * 其实工作中也是，一种方式实现有难度，可以采用另一种方式
	     *
	     * @param movePresent
	     */
	    private void upDataMoveAlpha(float movePresent) {
	        float finalApha = startAlpha - movePresent * 1;
	        //对亮度值进行最后的限定
	        if (finalApha >= 0 && finalApha <= 0.8) {   //这里系统没有为我们的透明度做上下限的约束，需要我们自己约束
	            //将透明度设置给控件
	            ViewCompat.setAlpha(viewVideoAlphaCover, finalApha);
	        }
	    }



* 初始化的时候发现黑屏增加，透明度初始化的操作

		//将透明度设置给控件
        ViewCompat.setAlpha(viewVideoAlphaCover, 0);




## 总时长和进度格式化处理 ##

* 时间长度的获取和当前播放时长的获取，必须在异步资源加载完成的调用中，不然视频加载失败等显示是没有意义的

	 	/**
         * 设置MediaPlayer的异步加载监听
         * 这个方法在资源异步加载完成后调用
         * 在给videoView设置完路径后直接的调用vdVideoview.start(); 可能会在资源异步加载还没完成的时候就调用播放start了
         */
        vdVideoview.setOnPreparedListener(new MediaPlayer.OnPreparedListener() {
            @Override
            public void onPrepared(MediaPlayer mp) {

            	.........
				 
                //初始化当前时间
                int currentPosition = vdVideoview.getCurrentPosition();
                tvVideoCurrentTime.setText(DateUtils.videoTimeFormat(currentPosition));
                //进度条进度值设置
                sbVideoCurrent.setProgress(currentPosition);
                upDataPlayPosition();

            }


* 更新当前播放时间和指示条进度UI的方法 upDataPlayPosition(),通过handler实现自动刷新
* handler使用不同的what值

			/**
		     * 视频播放进度更新
		     */
		    private void upDataPlayPosition() {
		        //获取实时播放进度并更新
		        int currentPosition = vdVideoview.getCurrentPosition();
		        tvVideoCurrentTime.setText(DateUtils.videoTimeFormat(currentPosition));
		        //进度条进度值设置
		        sbVideoCurrent.setProgress(currentPosition);
		        //通过延时消息循环更新
		        handler.sendEmptyMessageDelayed(WHAT_UPDATA_VIEDEOPOSITION,500);
		    }



* 拖动指示条改变进度，同一个seekBar监听器是可以设置给多个seekBar的，通过ID()区别

		 	//音量进度条拖动监听,seekBar是可以公用一个监听器的
	        MyOnSeekBarChangeListener seekBarChangeListener = new MyOnSeekBarChangeListener();
	        sbVideoCurrentVolume.setOnSeekBarChangeListener(seekBarChangeListener);
	        sbVideoCurrent.setOnSeekBarChangeListener(seekBarChangeListener);


* 监听其中的代码


		/**
	     * 当进度条改变的时候调用
	     * 媒体音量进度和视频播放进度公用一套
	     * seekBar的监听器是可以公用一套的，通过seekBar的id区别
	     */
	    private class MyOnSeekBarChangeListener implements SeekBar.OnSeekBarChangeListener {
	        @Override
	        public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
	            if (!fromUser) {
	                return;
	            }  //只处理来自用户的操作
	            switch (seekBar.getId()){
	                case R.id.sb_video_current_volume:
	                    /**
	                     * 根据进度条修改系统的音量
	                     *  参数1： 参数的类型（媒体音量还是通话等）
	                     *  参数2：目标值
	                     *  参数3： 是不是显示系统自带的Dialog 0：不显示，1：显示
	                     */
	                    setCurrentVolume(progress, 0);
	                    break;
	                case R.id.sb_video_current:
	                    //进度条进度值设置
	                    vdVideoview.seekTo(progress);
	                    break;
	            }
	
	        }


* 通过  
	                 
		   vdVideoview.seekTo(progress);

进度跳转




## 播放进度小细节调整 ##

* 播放完成handler消息移除
* 播放完成暂停按钮改变成播放按钮
* 暂停中handler消息移除
* 开始播放handler重新开始消息



* 添加OnCompletionListener()播放完成的回调方法

 		//视频播放结束监听
        vdVideoview.setOnCompletionListener(new MyOnCompletionListener());

* 在回调方法中完成按钮同步和消息移除

		/**
	     * 更能视频播放结束的时候此方法被调用
	     */
	    private class MyOnCompletionListener implements MediaPlayer.OnCompletionListener {
	        @Override
	        public void onCompletion(MediaPlayer mp) {
	            //当视频播放结束的时候次方法被调用
	            //解决部分视频播放完成视频时间没有同步完成的bug
	            upDataVideoTimeUI(vdVideoview.getDuration());
	            //视频播放完成，停止handler消息
	            handler.removeMessages(WHAT_UPDATA_VIEDEO_POSITION);
	
	            //同步视频播放按钮
	            upDataPauseStatus();
	             
	        }
	    }



* 暂停和播放切换中的代码


		/**
	     * 暂停更新的方法
	     * 作用： 切换暂停的状态和更新暂停按钮的图片
	     */
	    private void upDataPause() {
	        if (vdVideoview.isPlaying()) {
	            vdVideoview.pause();   //调用videoView的暂停方法
	        } else {
	            vdVideoview.start();   //调用videoView的播放方法
	        }
	    }



* upDataVideoTimeUI()中的代码

	
	 private void upDataVideoTimeUI(int currentPosition) {
	        tvVideoCurrentTime.setText(DateUtils.videoTimeFormat(currentPosition));
	        //进度条进度值设置
	        sbVideoCurrent.setProgress(currentPosition);
	    }
 

### 将播放菜单传递给播放界面 ###

* 在 VideoItem 中增加以下方法

		/**
	     * 根据传入的cursor 解析出对应的实体对象，以后的解析一般这么操作
	     *
	     * @param cursor
	     * @return
	     */
	    public static VideoItem purseVideoItem(Cursor cursor) {
	        if (cursor == null || cursor.getCount() == 0) {   //做一波健壮性检查 ， 以后的检查都这么做 ，不要先处理，最后检查，那样显得逻辑乱
	            return null;
	        }
	        VideoItem listItem = new VideoItem();
	        String tittle = cursor.getString(cursor.getColumnIndex(Media.TITLE));
	        String path = cursor.getString(cursor.getColumnIndex(Media.DATA));
	        long size = cursor.getLong(cursor.getColumnIndex(Media.SIZE));
	        int duration = cursor.getInt(cursor.getColumnIndex(Media.DURATION));
	        listItem.tittle = tittle;
	        listItem.path = path;
	        listItem.size = size;
	        listItem.duration = duration;
	        return listItem;
	    }
	
	    /**
	     * 获取视频列表
	     *
	     * @param cursor
	     * @return
	     */
	    public static ArrayList<VideoItem> purseVideoListItem(Cursor cursor) {
	        ArrayList<VideoItem> list = new ArrayList<>();
	        //做一下健壮性检查
	        if (cursor == null || cursor.getCount() == 0) {
	            return list;   //防止空指针
	        }
	        cursor.moveToPosition(-1);
	        int i= 0;
	        while (cursor.moveToNext()) {  //移动获取数据就可以了
	            VideoItem item =  VideoItem.purseVideoItem(cursor);
	            VideoItem videoItem = new VideoItem();
	            videoItem.setDuration(item.getDuration());
	            videoItem.setTittle(item.getTittle());
	            videoItem.setPath(item.getPath());
	            videoItem.setSize(item.getSize());
	
	            list.add(item);
	        }
	        return list;
	    }

* 记得  VideoItem 这个实体类的成员变量一定不可以是静态的，静态方法使用的变量不一定都是静态的，否则会出现list集合中的数据只有一个的情况

	 	private  String tittle;
	    private  String path;
	    private  long size;
	    private  int duration;


 
* **在网上搜索到的解释：**
		
		1、static变量
		
		　　按照是否静态的对类成员变量进行分类可分两种：一种是被static修饰的变量，叫静态变量或类变量；另一种是没有被static修饰的变量，叫实例变量。
		
		　　两者的区别是：
		
		　　对于静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问（方便），当然也可以通过对象来访问（但是这是不推荐的）。
		
		　　对于实例变量，没创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）。
		
		　　所以一般在需要实现以下两个功能时使用静态变量：
		
		在对象之间共享值时
		方便访问变量时
		
		
		
		* 静态的变量仅仅在当前的类引用的时候初始化一次（内存地址只进行一次分配），再次引用的时候将这个地址多次拷贝（节约内存）但是很容易出现值被覆盖的问题，以最后一次赋值为准



* 在 VideoListFragment 中的引用

	 		Cursor cursor = (Cursor) cursorListAdapter.getItem(position);

            //代码多一般的解析都不会放在这里，而是直接的放在been类中
            ArrayList<VideoItem> videoListItems = VideoItem.purseVideoListItem(cursor);


            //将数据传递到播放界面
            Intent intent = new Intent(getContext(), VideoPlayerActivity.class);
            intent.putExtra("videoListItems", videoListItems);
            intent.putExtra("position", position);
            startActivity(intent);



* 抽取播放界面播放代代码的公共部分

	 	/**
	     * 视屏播放切换，播放指定位置的视频
	     */
	    private void videoPlayPosition() {
	        videoItem = videoListItems.get(currentVideosPosition);
	        String videoPath = videoItem.getPath();
	        vdVideoview.setVideoPath(videoPath);    //设置播放路径
	        //公司要求快速开发的时候，可以使用系统自带的播放控制进度条，虽然丑但是还不错
	        //vdVideoview.setMediaController(new MediaController(this));
	        LogUtil.e(videoItem.toString());
	        //初始化标题
	        txVideoTittle.setText(videoItem.getTittle());
	    }

* 上一曲，下一曲播放监听并解决索引越界和按钮置灰


 		case R.id.iv_video_pre:    //上一视频按钮
                currentVideosPosition--;
                ivVideoPre.setEnabled(currentVideosPosition >= 0); //现在的条目小于0将状态设置伟不可点击
                ivVideoNext.setEnabled(currentVideosPosition < videoListItems.size());  //现在的条目大于制定的条目将状态设置伟不可点击
                if (currentVideosPosition < 0) {//现在的条目大于指定的条目不在进行播放操作
                    return;
                }
                videoPlayPosition();
                break;
        case R.id.iv_video_next:    //下一视频按钮
                currentVideosPosition++;
                ivVideoPre.setEnabled(currentVideosPosition >= 0); //现在的条目小于0将状态设置伟不可点击
                ivVideoNext.setEnabled(currentVideosPosition < videoListItems.size());  //现在的条目大于制定的条目将状态设置伟不可点击
                if (currentVideosPosition >= videoListItems.size()) {  //现在的条目大于指定的条目不在进行播放操作
                    return;
                }
                videoPlayPosition();
                break;



## 获取控制面板的高度，隐藏控制面板 ##


* 控件的大小是在View的measure的过程计算出来的。所有我们如果通过直接在onCreate()、onResume()等等方法中直接去取控件的大小是取不到的。 原因是View的measure过程和Activity的生命周期是不同步的，也就是说无法保证Activity中的onCreate()等等执行的时候View的measure()已经执行了，如果此时还没有执行肯定是得不到值的。

* **获取控件高度方式**
* 1.通过 `控件.getMeasuredHeight()` 方法获取控件的宽高

* 2.通过 `getHeight()` 方法

两种方式的比较

比较项目   	|控件.getMeasuredHeight() 或者 控件.getMeasuredHeight() 	 |getHeight()
------------|:------------------------------------------------------:|:-------:
调用的前提	|必须在前面添加代码 需要测量的控件.measure(0,0);表示使用估计值 |Activity中的View.Callback中的onWindowFocusChanged()监听中回调
获取时机		| 			在onCreate()中								 | 只有在OnGlobalLayoutListener()监听的回调方法中才会获取到宽高
准确性		|  在组合使用的时候不精确									 | 都是准确的
使用限制 	| 当两个控件同时占用一个屏幕，并且布局最外层中都是用match_parent时候不可使用 |无限制


* 两种代码如下：
* 使用回调方法的形式


		//这种方式更加的精确，但是执行效率厚底一些
        llVideoTop.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {

            @Override
            public void onGlobalLayout() {
                topH = llVideoTop.getHeight();
                LogUtil.e("上栏的高度："+ topH);
                llVideoTop.getViewTreeObserver().removeGlobalOnLayoutListener(this);
                ViewCompat.animate(llVideoTop).translationY(-topH).setDuration(500).setInterpolator(new AccelerateDecelerateInterpolator()).start();
            }
        });

* 直接使用 measure(0,0) 的形式
		
		  //这种方法的调用效率更高，优先执行
	        llVideoBottom.measure(0,0);
	        bottomH = llVideoBottom.getMeasuredHeight();
	        LogUtil.e("底部面板的高度： "+ bottomH);
	        ViewCompat.animate(llVideoBottom).translationY(bottomH).setDuration(500).setInterpolator(new AccelerateDecelerateInterpolator()).start();



* 总结： 
	* 1.回调监听会在 measure(0,0) 执行完了以后才会执行：
	* 2.大多数情况我们的布局中不会出现组合布局的形式，所以使用	measure(0,0) 的情况更多一些	



## 快捷键获取子类构造 ##

![](http://i.imgur.com/tdYzJd2.png)

## 快捷键实现快速查找重构的方法 ##



## 控制面板的隐藏操作   ##

* 初始化测量控件的高度和隐藏控制面板

		/**
	     * 获取顶部和底部控制栏的测量宽高
	     * 获取旷告是不可以在onCreate方法中直接的获取的到的
	     * 有两种方式获取的到，分别是：
	     * 1. 使用全局的监听回调，调用完成必须马上注销监听，不然一直回调；测量的结果就是实际的显示的效果，精确；慢效率低调用在measure()方法的后面
	     * 2. 使用布局加载时的估计值；；在层叠布局中不能使用；调用快，在控件渲染之前就已经侧来过完成，但是在层叠布局中不精确
	     */
	    private void hideContrlorOnInit() {
	        //创建布局监听器的形式获取控件的宽高
	        //这种方式更加的精确，但是执行效率厚底一些
	        llVideoTop.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
	
	            @Override
	            public void onGlobalLayout() {
	                topH = llVideoTop.getHeight();
	                LogUtil.e("上栏的高度：" + topH);
	                llVideoTop.getViewTreeObserver().removeGlobalOnLayoutListener(this);
	                ViewCompat.animate(llVideoTop).translationY(-topH).setDuration(500).setInterpolator(new AccelerateDecelerateInterpolator()).start();
	                //更改面板状态的标志位
	                MenuShowing=false;
	            }
	        });
	        //这种方法的调用效率更高，优先执行
	        llVideoBottom.measure(0, 0);
	        bottomH = llVideoBottom.getMeasuredHeight();
	        LogUtil.e("底部面板的高度： " + bottomH);
	        ViewCompat.animate(llVideoBottom).translationY(bottomH).setDuration(500).setInterpolator(new AccelerateDecelerateInterpolator()).start();
	    }

* 两种放肆都有使用到，方便后期看的时候想起来

* 因为 `ViewTreeObserver.OnGlobalLayoutListener()` 的方式测量的时候是界面绘制出来，因此调用的时候` llVideoBottom.measure(0, 0);` 的宽高一定都是测量好的了

* 界面的手势操作需要借助手势分析器

* 在 initListener() 中创建监听，创建的时候需要传入一个 `OnGestureListener` 看构造 `public GestureDetector(Context context, OnGestureListener listener)` 他实现的方法太多了，考虑使用子类，快捷键获取子类构造 得到 `SimpleOnGestureListener()`
 	 

		//注册手势监听器,使用的时候需要将当前的系统的触摸事件交给他，才能分析
        //原来的类实现的抽象方法太多的时候，可以考虑使用他的子类
        gestureDetector = new GestureDetector(this, new mySimpleOnGestureListener());	



* 要想分析触摸事件，需要在 `onTouchEvent() ;` 中将触摸事件传递过去
 

	 	 public boolean onTouchEvent(MotionEvent event) {
        //屏幕的手势分析器如果分析手势的操作，必须先获取到当前的触摸事件
        gestureDetector.onTouchEvent(event);

		......
		}


* mySimpleOnGestureListener()中的回调代码，Ctrl + o 重写对应的方法


		 /**
	     * 手势分析器
	     */
	    private class mySimpleOnGestureListener extends GestureDetector.SimpleOnGestureListener {
	        /**
	         * 这个是单击
	         *
	         * @param e
	         * @return
	         */
	        @Override
	        public boolean onSingleTapConfirmed(MotionEvent e) {
	            switchControlor();
	            return super.onSingleTapConfirmed(e);
	        }
	
	        /**
	         * 这个是只要点击就调用
	         *
	         * @param e
	         * @return
	         */
	        @Override
	        public boolean onSingleTapUp(MotionEvent e) {
	
	            return super.onSingleTapUp(e);
	        }
	    }

		
* 创建 `switchControlor()` 方法，改变控制栏的状态


		 /**
	     * 切换控制面板的显示状态
	     */
	    private void switchControlor() {
	        //如果是开就变成关，如果是关就变开
	
	        if (MenuShowing) {
	            //这两种方式的区别，很显然 translationYBy(topH)实在移动后的基础上移动，translationY(bottomH)在布局文件基础上每次都是
	            //ViewCompat.animate(llVideoTop).translationYBy(topH).setDuration(500).setInterpolator(new AccelerateDecelerateInterpolator()).start();
	            ViewCompat.animate(llVideoTop).translationY(-topH).setDuration(300).setInterpolator(new AccelerateDecelerateInterpolator()).start();
	            ViewCompat.animate(llVideoBottom).translationY(bottomH).setDuration(300).setInterpolator(new AccelerateDecelerateInterpolator()).start();
	        } else {
	            ViewCompat.animate(llVideoTop).translationY(0).setDuration(300).setInterpolator(new AccelerateDecelerateInterpolator()).start();
	            ViewCompat.animate(llVideoBottom).translationY(0).setDuration(300).setInterpolator(new AccelerateDecelerateInterpolator()).start();
	        }
	        MenuShowing=!MenuShowing;
	
	    }

* 不要忘记创建变量记录状态栏的信息

	private boolean MenuShowing；


* 在改变状态栏的地方改变他的状态

## 延时隐藏控制面板 ##
* 在打开面板的时候发送演示消息，并且移除上一次的消息防止干扰

	 	 /**
	     * 切换控制面板的显示状态
	     */
	    private void switchControlor() {
	        //如果是开就变成关，如果是关就变开
	
	        if (MenuShowing) {
	            hideControlor();
	        } else {
	            showControlor();
	            //清除上一次的操作   ，代码是成对出现的最好放在一起
	            handler.removeMessages(WHAT_HIDE_CONTROLOR);
	            //打开面板的时候，延时5s自动关闭
	            handler.sendEmptyMessageDelayed(WHAT_HIDE_CONTROLOR, 5000);
	        }

* 代码抽取
 
	  	/**
	     * 控制面板显示
	     */
	    private void showControlor() {
	        ViewCompat.animate(llVideoTop).translationY(0).setDuration(300).setInterpolator(new AccelerateDecelerateInterpolator()).start();
	        ViewCompat.animate(llVideoBottom).translationY(0).setDuration(300).setInterpolator(new AccelerateDecelerateInterpolator()).start();
	        MenuShowing = true;
	    }
	
	    /**
	     * 控制面板隐藏
	     */
	    private void hideControlor() {
	        //这两种方式的区别，很显然 translationYBy(topH)实在移动后的基础上移动，translationY(bottomH)在布局文件基础上每次都是
	        //ViewCompat.animate(llVideoTop).translationYBy(topH).setDuration(500).setInterpolator(new AccelerateDecelerateInterpolator()).start();
	        ViewCompat.animate(llVideoTop).translationY(-topH).setDuration(300).setInterpolator(new AccelerateDecelerateInterpolator()).start();
	        ViewCompat.animate(llVideoBottom).translationY(bottomH).setDuration(300).setInterpolator(new AccelerateDecelerateInterpolator()).start();
	        MenuShowing = false;
	    } 



* 进度条操作的时候移除小消息

	 


		/**
	     * 当进度条改变的时候调用
	     * 媒体音量进度和视频播放进度公用一套
	     * seekBar的监听器是可以公用一套的，通过seekBar的id区别
	     */
	    private class MyOnSeekBarChangeListener implements SeekBar.OnSeekBarChangeListener {
	        @Override
	        public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {

	           。。。。

	        }
	
	        @Override
	        public void onStartTrackingTouch(SeekBar seekBar) {
	            //清除上一次的操作   ，代码是成对出现的最好放在一起
	            handler.removeMessages(WHAT_HIDE_CONTROLOR);
	
	        }
	
	        @Override
	        public void onStopTrackingTouch(SeekBar seekBar) {
	            //打开面板的时候，延时5s自动关闭
	            handler.sendEmptyMessageDelayed(WHAT_HIDE_CONTROLOR, 5000);
	        }
	    }


* handler接收消息并处理

		Handler handler = new Handler() {
	        @Override
	        public void handleMessage(Message msg) {
	            super.handleMessage(msg);
	            switch (msg.what) {
	                case WHAT_UPDATASYSTEM_TIME:
	                    upDataSystemTime();
	                    break;
	                case WHAT_UPDATA_VIEDEO_POSITION:
	                    upDataPlayPosition();    //实时播放时间更新
	                    break;
	                case WHAT_HIDE_CONTROLOR:
	                    hideControlor();    //5s延时到，隐藏控制面板
	                    break;
	            }
	        }
	    };


## 全屏切换操作 ##

* VideoView的默认的全屏是跟随视屏的宽高比例的，因此宽和高总有一个是不能填充窗体的
* VideoView在初始化的时候会被重新的计算宽高

* 而VideoView 的父类 SurfaceView 是跟随xml文件布局的不会自动得计算


* 1.实现屏幕切换生效，必须先将 VideoView设置一个属性  `android:layout_centerInParent="true"` 至于为什么需要查看源码
 	 	
		<com.itcast.zbc.mediaplayer.view.VideoView
	        android:layout_centerInParent="true"
	        android:id="@+id/vd_videoview"
	        android:layout_width="match_parent"
	        android:layout_height="match_parent" />

* 2.拷贝sdk中的VideoView源码(Android是开源的，只一点比较好)，解决报错问题
	* 1.使用的 VideoView.java 一定是来自sdk 18 的，小于这个版本的兼容性不可以，大于的报错的方法太多，不好修改
	 
	* 2.在 `onMeasure()` 方法的最后记录处理好的宽高

 			protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {

				......

				// 记录原始的控件大小(这个大小实在屏幕的基础上调整得到的)
	            mDefaultH = height;
	            mDefaultW = width;
			}

	* 3.在  `private void initVideoView(Context context) ` 初始化方法中初始化记录全屏的宽高和mContext
				
	
			// 初始化自定义的变量
	        mContext =context;
	        WindowManager windowManager= (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
	             mScreenW = windowManager.getDefaultDisplay().getWidth();
	             mScreenH = windowManager.getDefaultDisplay().getHeight();
			



* 3.在VideoView中添加一下方法：
	* 1.全屏切换

		    // 如果当前是全屏状态则切换到默认的大小，否则切换到全屏大小
		    public void switchFullScreen(){
		        if (isFullSreen){
		            // 全屏状态，切换到默认大小
		            getLayoutParams().width = mDefaultW;
		            getLayoutParams().height = mDefaultH;
		            LogUtil.e("VideoView.switchFullScreen,mDefaultW="+mDefaultW+";mDefaultH="+mDefaultH+";isFullSreen="+isFullSreen);
		            LogUtil.e("VideoView.switchFullScreen,mScreenW="+mScreenW+";mScreenH="+mScreenH+";isFullSreen="+isFullSreen);
		        }else {
		
		            // 非全屏状态，切换到全屏大小
		            getLayoutParams().width = mScreenW;
		            getLayoutParams().height = mScreenH;
		            LogUtil.e("VideoView.switchFullScreen,mDefaultW="+mDefaultW+";mDefaultH="+mDefaultH+";isFullSreen="+isFullSreen);
		            LogUtil.e("VideoView.switchFullScreen,mScreenW="+mScreenW+";mScreenH="+mScreenH+";isFullSreen="+isFullSreen);
		        }
		        // 刷新控件大小
		        requestLayout();
		        isFullSreen = !isFullSreen;
		    }

	* 2.获取当前屏幕状态

		    /** 如果返回 true 说明当前是全屏状态 */
		    public boolean isFullSreen() {
		        return isFullSreen;
		    }

* 4.使用全局变量记录当前的全屏状态

		// 自定义的变量
	    private  Context mContext;
	    //默认尺寸
	    private int mDefaultH;
	    private int mDefaultW;
	    //屏幕尺寸
	    private int mScreenH;
	    private int mScreenW;
	    /** 如果为true，则说明当前是全屏状态 */
	    private boolean isFullSreen = false;



## 双击操作和单击处理 ##
 
* 在手势分析器 `SimpleOnGestureListener` 中添加双击操作 `onDoubleTap()` 和长按操作  `onLongPress()`  

		/**
	     * 手势分析器
	     */
	    private class mySimpleOnGestureListener extends GestureDetector.SimpleOnGestureListener {
	        /**
	         * 这个是单击
	         *
	         * @param e
	         * @return
	         */
	        @Override
	        public boolean onSingleTapConfirmed(MotionEvent e) {
	            switchControlor();
	            return super.onSingleTapConfirmed(e);
	        }
	
	        /**
	         * 双击时调用
	         * 双击全屏切换
	         * @param e
	         * @return
	         */
	        @Override
	        public boolean onDoubleTap(MotionEvent e) {
	            // LogUtil.e("onDoubleTap");
	            vdVideoview.switchFullScreen();
	            upDatabtnFullScreen();
	            return super.onDoubleTap(e);
	        }
	
	
	        /**
	         * 长按时调用
	         * 长按暂停
	         * @param e
	         */
	        @Override
	        public void onLongPress(MotionEvent e) {
	            //LogUtil.e("onLongPress");
	            upDataPause();
	            upDataPauseStatus();
	            super.onLongPress(e);
	        }
	    }



## 添加外部文件播放的功能 ##

* 这个功能可以让我们轻松的在资源管理器中找到的视频可以在我们的app中播放


![](http://i.imgur.com/1LCHVuX.png)


* 1.这个是通过意图广播来完成的，主要在我们的app清单文件的activity下添加以下代码


		<!--视频播放界面-->
        <!--android:screenOrientation="landscape"设置播放界面为横向
        android:theme="@android:style/Theme.Holo.Light.NoActionBar.Fullscreen"  设置当前activity全屏-->
        <activity
            android:name=".ui.activity.VideoPlayerActivity"
            android:screenOrientation="landscape">
            <!--添加文件管理器启动视频播放的拦截-->
            <intent-filter>
                <action android:name="android.intent.action.VIEW" />

                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.BROWSABLE" />
 
				<!--匹配可以接收流媒体rtsp格式的文件-->
                <data android:scheme="rtsp" />
            </intent-filter>
            <intent-filter>
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />

				<!--匹配可以接收流媒体sdp格式的视频文件-->
                <data android:mimeType="video/*" />
                <data android:mimeType="application/sdp" />
            </intent-filter>
            <intent-filter>
                <action android:name="android.intent.action.VIEW" />

                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.BROWSABLE" />

				<!--匹配可以接收来自网页http协议的MP4，3dp等格式的格式的视频，需要的话还可以添加-->
                <data android:scheme="http" />
                <data android:mimeType="video/mp4" />
                <data android:mimeType="video/3gp" />
                <data android:mimeType="video/3gpp" />
                <data android:mimeType="video/3gpp2" />
            </intent-filter>
        </activity>

* 2.完成上面的代码，在文件管理器中代开视频会触发下面的方法

		/**
         * 外部打开媒体处理
         */
        //content://media/external/video/media/56937
        Uri uri = getIntent().getData();
        if (uri != null) {   //内容不为空，说明是一个通过文件管理器打开的视频
            if (uri.toString().contains("content://media/")) {   //如果是媒体库地址，获取到的是一个内容提供者提供的地址
                uri = conrentTransformUri(uri);
            }//如果不是媒体库形式的uri那就是一个真实路径的了后面的就统一处理
            LogUtil.e("uri=" + uri);
            vdVideoview.setVideoURI(uri);  //播放外部打开的指定视频
            //初始化标题
            txVideoTittle.setText(uri.getPath());
            //将上一曲和下一曲禁用
            ivVideoPre.setEnabled(false);
            ivVideoNext.setEnabled(false);
        } else {   //uri为空，说明是本地打开的视频
            videoListItems = (ArrayList<VideoItem>) getIntent().getSerializableExtra("videoListItems");
            //做一波健壮性检查
            if (videoListItems.size() == 0 || videoListItems == null) {
                return;
            }
            currentVideosPosition = getIntent().getIntExtra("position", 0);
            LogUtil.e("currentPosition" + currentPosition);
            //初始化播放选中位置的视频
            videoPlayPosition();
        }


* 会在 `Uri uri = getIntent().getData();` 中获取到一个需要播放的媒体的uri ，但是不同的文件管理器的传送的方式不一样，我的华为手机传送的是一个这样格式的路径  uri=    `content://media/external/video/media/56937` 这个是我的uri ，是一个媒体库的存储位置，没法直接的播放需要转换成 uri=  `file:///storage/sdcard1/test/video/oppo%20-%202.mp4` 的形式

* 3.这个方法已经被我封装好了，使用的时候可以改成一个工具类，同时查询的媒体库还可以改成  `String[] proj = {MediaStore.Audio.Media.DATA};` 图片等

		/**
	     * 将媒体库的路径转换成真实物理存储地址
	     *
	     * @param contentUri content://media/external/video/media/56937
	     * @return 真实的物理地址uri
	     */
	    private Uri conrentTransformUri(Uri contentUri) {
	        String[] proj = {MediaStore.Video.Media.DATA};
	        Cursor actualimagecursor = this.managedQuery(contentUri, proj, null, null, null);
	        int actual_image_column_index = actualimagecursor.getColumnIndexOrThrow(MediaStore.Video.Media.DATA);
	        actualimagecursor.moveToFirst();
	
	        String img_path = actualimagecursor.getString(actual_image_column_index);
	        File file = new File(img_path);
	        return Uri.fromFile(file);
	    }



* 最后介绍一下URI的组成

		就Android平台而言，URI主要分三个部分：scheme, authority and path。其中authority又分为host和port。格式如下：
		scheme://host:port/path
		举个实际的例子：
		content://com.example.project:200/folder/subfolder/etc
		\---------/  \---------------------------/ \---/ \--------------------------/
		scheme                 host               port        path
		                \----------------------------/
		                          authority   

scheme  | 协议名 ; 一般的有 `http://   content://  file:// svn：//` 等这都是常用的
--------|-----
host    |主机名或服务器名
port	|端口号
path	|相对路径




## 播放网络视频 ##

* 创建一个新的应应用发送对应我们app匹配器的意图即可
* 新应用的代码如下：

		 public void start(View v) {
	        Intent intent = new Intent();
	        intent.setDataAndType(Uri.parse("http://192.168.199.247/qwer1.avi"), "video/avi");
	        startActivity(intent);
	    }

* `video/avi` 对应我们应用中的 `<data android:mimeType="video/mp4" />`



## 网络加载视频缓冲显示第二进度 ##

* 首先在seekBar的xml文件中定义第二进度

		<?xml version="1.0" encoding="utf-8"?>
 

		<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
		
		    <item
		        android:id="@android:id/background"
		        android:drawable="@drawable/video_seekbar_bg">
		        <!--<shape>
		            <corners android:radius="5dip" />
		            <gradient
		                android:startColor="#ff9d9e9d"
		                android:centerColor="#ff5a5d5a"
		                android:centerY="0.75"
		                android:endColor="#ff747674"
		                android:angle="270"
		                />
		        </shape>-->
		    </item>
		
		    <item android:id="@android:id/secondaryProgress">
		        <clip>
		            <shape>
		                <corners android:radius="5dip" />
		                <solid android:color="@color/half_white" />
		
		                <!--这是一个渐变色-->
		                <!-- <gradient
		                     android:startColor="#80ffd300"
		                     android:centerColor="#80ffb600"
		                     android:centerY="0.75"
		                     android:endColor="#a0ffcb00"
		                     android:angle="270"
		                     />-->
		            </shape>
		        </clip>
		

		    </item>
		
		    <item
		        android:id="@android:id/progress"
		        android:drawable="@drawable/video_seekbar_progress">
		        <!-- <clip>
		             <shape>
		                 <corners android:radius="5dip" />
		                 <gradient
		                     android:startColor="#ffffd300"
		                     android:centerColor="#ffffb600"
		                     android:centerY="0.75"
		                     android:endColor="#ffffcb00"
		                     android:angle="270"
		                     />
		             </shape>
		         </clip>-->
		
		    </item>
		
		</layer-list>
		
* <clip>标签		
* **重点来了：** 使用剪切图像资源可以只显示一部分图像，这种资源经常被用在进度条的制作上。剪切图像资源是一个XML格式文件，资源只包含一个<clip>标签。
* 这是以前定义的xml文件在使用在progressBar的时候会变粗的原因
 

* 初始化第二进度为 0
   	 	
		<SeekBar
            android:id="@+id/sb_video_current"
            style="@android:style/Widget.SeekBar"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_marginRight="10dp"
            android:layout_weight="1"
            android:maxHeight="6dp"
            android:minHeight="6dp"
            android:progress="40"
            android:progressDrawable="@drawable/video_progress_seekbar"
            android:thumb="@mipmap/video_progress_thumb"
            android:secondaryProgress="0"     //第二进度初始化为0
            android:thumbOffset="0dp" />	  


* 有一个重点： 

* 阅读 VideoView 的时候发现，VideoView 是通过 `mMediaPlayer.setOnBufferingUpdateListener(mBufferingUpdateListener);` 将进度监听器 `mBufferingUpdateListener` 最终传递给 MediaPlayer 的

 		//最终将传递的这个缓冲监听器传递给了 MediaPlayer
        mMediaPlayer.setOnBufferingUpdateListener(mBufferingUpdateListener);



* 并且将当前的缓冲进度存储在了  `mCurrentBufferPercentage` 当中
 
	 	/**
	     * 系统原有的监听器是不对外公开的，想要监听只有通过获取进度，自己刷新的形式，这种情况耗费更多的资源
	     */
	   private MediaPlayer.OnBufferingUpdateListener mBufferingUpdateListener =
            new MediaPlayer.OnBufferingUpdateListener() {
                public void onBufferingUpdate(MediaPlayer mp, int percent) {
                    mCurrentBufferPercentage = percent;
                    LogUtil.e(VideoView.class,"percent::::"+percent);
                }
        };

* 并通过 `getBufferPercentage()` 方法最终获取到这个缓冲的百分比

		@Override
	    public int getBufferPercentage() {
	        if (mMediaPlayer != null) {
	            return mCurrentBufferPercentage;
	        }
	        return 0;
	    }


* 于是第二进度条的刷新出现了两种方式


* 1.第一种在无法修改 VideoView 源码的情况下，通过handler延时消息实现界面的刷新

		  case WHAT_UPDATA_PROGRESS_BUFFERING:
                    //加载缓冲百分比
                    int duration = vdVideoview.getDuration();
                    int bufferPercentage = vdVideoview.getBufferPercentage();
                    LogUtil.e("duration====" + duration + "_____bufferPercentage====" + bufferPercentage);
                    handler.sendEmptyMessageDelayed(WHAT_UPDATA_PROGRESS_BUFFERING, 400);
                    break;

* 但是这种方式是有弊端的，就是我们不知道什么时候开始刷新，至于频率： 通过log发现在100ms---200ms 左右最有最好

* 第二种方式学习系统，传递一个  `MediaPlayer.OnBufferingUpdateListener mBufferingUpdateListener` 带回我们所需要的信息

* 具体实现：
* 在	VideoView中添加以下的代码	

		// 允许从外部设置缓冲监听
	    private MediaPlayer.OnBufferingUpdateListener mBufferingUpdateListener ;
	
	
	    /**
	     * 获外部触底过来的进度监听器
	     * @param mBufferingUpdateListener
	     */
	    public void setBufferingUpdateListener(MediaPlayer.OnBufferingUpdateListener mBufferingUpdateListener) {
	        this.mBufferingUpdateListener = mBufferingUpdateListener;
	    }


* 在播放界面添加监听器

	 vdVideoview.setBufferingUpdateListener(new MediaPlayer.OnBufferingUpdateListener() {
            @Override
            public void onBufferingUpdate(MediaPlayer mp, int percent) {
                LogUtil.e(VideoView.class, "percent::::" + percent);
                if (vdVideoview.getCurrentPosition() == vdVideoview.getDuration() && percent == 100) {   //刷新进度再次达到100%刷新完成不在刷新
                    return;
                }
                float loadingProgress = vdVideoview.getDuration() * percent / 100f;    //将缓存进度进行换算
                sbVideoCurrent.setSecondaryProgress((int) loadingProgress);
            }
        });

* 这样最终就可以将MediaPlayer的回调消息带回来了


## 总结回调这一部分我们还们有学习到他的精髓，一定要再次的深入学习 ##

* 回调可以向子类传递，亦可以向父类传递

	具体的总结为，返回值传递给父类  比如BaseActivity `public View getView()；`
				参数传递给子类    比如  `public void onClickListener(View.OnClickListener listener)`

## 代码书写规范的一些问题 ##

* 先看以下人家的代码：

 
![](http://i.imgur.com/Zdmi7Ql.png)

* 将相同的逻辑放在一起，这样看起来很清爽


## 网络缓存加载进度条处理 ##

* 添加监听

		vdVideoview.setOnInfoListener(new MyOnInfoListener());

* `MyOnInfoListener()` 中的代码

		/**
	     * 当视频不放过程中，缓存属性发生变化时被回调
	     * 在这里处理了缓冲进度条
	     */
	    private class MyOnInfoListener implements MediaPlayer.OnInfoListener {
	        @Override
	        public boolean onInfo(MediaPlayer mp, int what, int extra) {
	            switch (what) {
	                case MediaPlayer.MEDIA_INFO_BAD_INTERLEAVING:
	                    ToastUtil.showToastShort("当前网络差");
	                    break;
	                case MediaPlayer.MEDIA_INFO_BUFFERING_START:   //视频播放过程中，缓冲开始
	                    llVideoLoadingInplaying.setVisibility(View.VISIBLE);
	                    break;
	                case MediaPlayer.MEDIA_INFO_BUFFERING_END:     //视频播放过程中，缓冲结束
	                    llVideoLoadingInplaying.setVisibility(View.GONE);
	                    break;
	            }
	            return false;
	        }
	    }


## 视屏播放错误的处理，通过Dialog弹层提示 ##

* 添加监听

        vdVideoview.setOnErrorListener(new MyOnErrorListener());

* `MyOnErrorListener` 中的代码

		 /**
	     * 视频播放错误时回调
	     */
	    private class MyOnErrorListener implements MediaPlayer.OnErrorListener {
	        @Override
	        public boolean onError(MediaPlayer mp, final int what, int extra) {
	            String errMsg="";
	            switch (what){
	                case MediaPlayer.MEDIA_ERROR_TIMED_OUT:
	                    errMsg="网络连接超时，请检查网络或服务器无资源";
	                    break;
	                case MediaPlayer.MEDIA_ERROR_UNKNOWN:
	                    errMsg="未知的服务器或视频";
	                    break;
	                case MediaPlayer.MEDIA_ERROR_UNSUPPORTED:
	                    errMsg="暂不支持的视频格式";
	                    break;
	            }
	            //通过dialog提示错误信息
	            AlertDialog.Builder dialog =new AlertDialog.Builder(VideoPlayerActivity.this);
	            dialog.setIcon(R.mipmap.notification_music_playing);
	            dialog.setTitle("警告");
	            dialog.setMessage(TextUtils.isEmpty(errMsg)?"该视屏无法播放":errMsg);
	            dialog.setPositiveButton("确定", new DialogInterface.OnClickListener() {
	                @Override
	                public void onClick(DialogInterface dialog, int which) {
	                   finish();
	                }
	            });
	            dialog.create().show();
	            return false;
	        }
	    }



